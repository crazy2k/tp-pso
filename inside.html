
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>El sistema por dentro &mdash; Trabajo Práctico de Programación de Sistemas Operativos v1.0 documentation</title>
    <link rel="stylesheet" href="static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="Trabajo Práctico de Programación de Sistemas Operativos v1.0 documentation" href="index.html" />
    <link rel="next" title="Convenciones para el código de este trabajo" href="conventions.html" />
    <link rel="prev" title="Trabajo Práctico de Programación de Sistemas Operativos" href="index.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="conventions.html" title="Convenciones para el código de este trabajo"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Trabajo Práctico de Programación de Sistemas Operativos"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Trabajo Práctico de Programación de Sistemas Operativos v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="el-sistema-por-dentro">
<h1>El sistema por dentro<a class="headerlink" href="#el-sistema-por-dentro" title="Permalink to this headline">¶</a></h1>
<p>El sistema operativo de este proyecto consta de un <em>kernel</em> monolítico muy
sencillo. Algunas de las características del kernel, al momento de escribir
este documento, son:</p>
<ul class="simple">
<li><strong>carga de programas</strong> desde ejecutables con un formato propio (PSO)</li>
<li><strong>protección de memoria</strong> utilizando paginación y espacios de memoria
diferentes para las tareas</li>
<li>manejador de interrupciones que permite el <strong>registro de
handlers en tiempo de ejecución</strong></li>
<li><strong>scheduling de procesos utilizando round-robin</strong> con <em>quantum</em> fijo</li>
<li><strong>task-switching por software</strong></li>
<li>atención de <strong>llamadas al sistema</strong></li>
<li><strong>controladores</strong> de consolas, puerto serie y disco rígido ATA</li>
<li><strong>sistema de archivos virtual</strong> (primitivo) y soporte para lectura de
ext2</li>
</ul>
<p>En este documento se describen estas y otras características del sistema.</p>
<div class="section" id="la-estructura-de-directorios">
<h2>La estructura de directorios<a class="headerlink" href="#la-estructura-de-directorios" title="Permalink to this headline">¶</a></h2>
<p>Si bien la parte más importante del proyecto está escrita en C, en realidad,
este también se compone de archivos con código <em>assembly</em> de x86, <em>scripts</em> de
utilidad y de configuración de herramientas, archivos binarios y
documentación. Todo estos archivos están organizados en una estructura de
directorios que facilita su búsqueda.</p>
<p>Esta es una síntesis de la estructura de directorios del proyecto:</p>
<p class="graphviz">
<img src="images/graphviz-05a56a1b0eb24ecb581b580cff955a91a342881f.png" alt="digraph direcciones {
    &quot;raíz&quot; [shape=box]
    &quot;src/&quot; [shape=box]
    &quot;doc/&quot; [shape=box]
    &quot;bin/&quot; [shape=box]
    &quot;boot/&quot; [shape=box]
    &quot;include/&quot; [shape=box]
    &quot;kernel/&quot; [shape=box]
    &quot;tasks/&quot; [shape=box]
    &quot;raíz&quot; -&gt; &quot;src/&quot;
    &quot;raíz&quot; -&gt; &quot;doc/&quot;
    &quot;src/&quot; -&gt; &quot;bin/&quot;
    &quot;src/&quot; -&gt; &quot;boot/&quot;
    &quot;src/&quot; -&gt; &quot;include/&quot;
    &quot;src/&quot; -&gt; &quot;kernel/&quot;
    &quot;src/&quot; -&gt; &quot;tasks/&quot;
}" />
</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Directorio</th>
<th class="head">Contenido</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><a href="#id1"><span class="problematic" id="id2">**</span></a>raíz</td>
<td>representa la base de la estructura de directorios. Además
de contener al resto de los directorios, posee archivos de
alcance global en el proyecto.</td>
</tr>
<tr><td><strong>src/</strong></td>
<td>posee todos los archivos y directorios referidos al
proyecto menos la documentación</td>
</tr>
<tr><td><strong>src/bin/</strong></td>
<td>es el directorio en el que se hallará la imagen del kernel
y los archivos correspondientes al disco floppy y disco
rígido una vez se realice la compilación del código.
Además, posee el código binario correspondiente a los BIOS
de bochs.</td>
</tr>
<tr><td><strong>src/boot/</strong></td>
<td>alberga el código fuente del bootloader.</td>
</tr>
<tr><td><strong>src/include/</strong></td>
<td>posee los encabezados del kernel.</td>
</tr>
<tr><td><strong>src/kernel/</strong></td>
<td>contiene el código fuente del kernel y además alberga los
archivos objeto resultantes de su compilación.</td>
</tr>
<tr><td><strong>src/tasks/</strong></td>
<td>contiene el código fuente y objeto de las tareas de
usuario y también archivos relacionados con el formato de
ejecutable propio.</td>
</tr>
<tr><td><strong>doc/</strong></td>
<td>contiene los fuentes de la documentación y algunas
utilidades para construirla.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="manejo-de-procesos">
<h2>Manejo de procesos<a class="headerlink" href="#manejo-de-procesos" title="Permalink to this headline">¶</a></h2>
<p>La ejecución y el manejo de tareas (o procesos <a class="footnote-reference" href="#id4" id="id3">[1]</a>) es una parte
importante de cualquier sistema operativo. Este sistema no es la excepción.</p>
<p>El manejo de las tareas se encuentra repartido en los módulos <tt class="docutils literal"><span class="pre">sched</span></tt>
(<tt class="docutils literal"><span class="pre">src/kernel/sched.c</span></tt>) y <tt class="docutils literal"><span class="pre">loader</span></tt> (<tt class="docutils literal"><span class="pre">src/kernel/loader.c</span></tt>). El primero se
ocupa estrictamente del algoritmo de <em>scheduling</em>, mientras que el segundo se
encarga de la creación efectiva de los procesos, de los cambios de contexto,
entre otras cosas.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>Usamos los términos &#8220;tarea&#8221; y &#8220;proceso&#8221; de manera
intercambiable.</td></tr>
</tbody>
</table>
<div class="section" id="el-descriptor-de-proceso">
<h3>El descriptor de proceso<a class="headerlink" href="#el-descriptor-de-proceso" title="Permalink to this headline">¶</a></h3>
<p>Cada tarea es representada en el <em>scheduler</em> (<tt class="docutils literal"><span class="pre">sched</span></tt>) por una
estructura <tt class="docutils literal"><span class="pre">sched_task</span></tt> cuya definición puede hallarse en
<tt class="docutils literal"><span class="pre">kernel/sched.c</span></tt>:</p>
<div class="highlight-python"><pre>struct sched_task {
    bool blocked;
    uint32_t quantum;
    uint32_t rem_quantum;

    sched_task *next;
    sched_task *prev;
};</pre>
</div>
<p>Esta estructura contiene todo lo que el scheduler precisa saber sobre la
tarea. Entre estas cosas, se encuentra el quantum asociado a la tarea, el
quantum que le queda por consumir y un <em>flag</em> que indica si la tarea se
encuentra bloqueada.</p>
<p>Por otro lado, el módulo <tt class="docutils literal"><span class="pre">loader</span></tt> define una estructura <tt class="docutils literal"><span class="pre">pcb</span></tt> para cada
tarea. La definición de esta estructura se encuentra en <tt class="docutils literal"><span class="pre">kernel/loader.c</span></tt>:</p>
<div class="highlight-python"><pre>struct pcb {
    // Direccion virtual y fisica del directorio de paginas en cualquier
    // espacio de direcciones
    void *pd;

    // Datos sobre el stack de kernel de la tarea
    void *kernel_stack;
    void *kernel_stack_limit;
    void *kernel_stack_pointer;

    // File descriptors
    chardev *fds[MAX_FD];
    uint32_t last_fd;

    pcb *next;
    pcb *prev;
};</pre>
</div>
<p>Esta estructura contiene datos sobre el <em>stack</em> de kernel de la tarea (su
dirección virtual, el valor del puntero del stack), la dirección del
directorio de páginas de la tarea y el arreglo de archivos abiertos por
la tarea.</p>
</div>
<div class="section" id="el-scheduler">
<h3>El <em>scheduler</em><a class="headerlink" href="#el-scheduler" title="Permalink to this headline">¶</a></h3>
<p>El algoritmo de <em>scheduling</em> utilizado es extremadamente sencillo:
<em>round-robin</em> con quantums fijos. A cada tarea se le asigna,
inicialmente, un número fijo de unidades de tiempo para su ejecución.
Cada unidad de tiempo equivale a una interrupción del <em>timer</em>.</p>
<p>Las tareas pueden estar bloqueadas (<tt class="docutils literal"><span class="pre">blocked</span> <span class="pre">=</span> <span class="pre">TRUE</span></tt>) o disponibles
para ser ejecutadas (<tt class="docutils literal"><span class="pre">blocked</span> <span class="pre">=</span> <span class="pre">FALSE</span></tt>). Cuando están disponibles,
pueden encontrarse en ejecución o a la espera de su turno. Como el
kernel sólo maneja un único procesador, en todo momento hay a lo sumo
una única tarea en ejecución.</p>
<p>La administración se realiza mediante una lista doblemente enlazada
circular de procesos. La cabeza de esta lista es siempre el proceso
actualmente en ejecución. Cuando se acaba el quantum de una tarea, la
cabeza pasa a ser la siguiente tarea en la lista que se encuentre
en condiciones de ser ejecutada. Cuando una tarea finaliza su ejecución
(por ejemplo, al invocar ella misma a la llamada al sistema <tt class="docutils literal"><span class="pre">exit()</span></tt>)
esta es quitada de la lista y los recursos que utilizaba son liberados.</p>
<p>El scheduler exporta una función para cada tipo de evento:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">sched_load()</span></tt> para la carga de la tarea,</li>
<li><tt class="docutils literal"><span class="pre">sched_block()</span></tt> y <tt class="docutils literal"><span class="pre">sched_unblock()</span></tt> para los eventos de bloqueo y
desbloqueo de la tarea,</li>
<li><tt class="docutils literal"><span class="pre">sched_tick()</span></tt> para la ocurrencia de un <em>tick</em> del timer,</li>
<li><tt class="docutils literal"><span class="pre">sched_exit()</span></tt> para la terminación de una tarea.</li>
</ul>
</div>
<div class="section" id="creacion-de-tareas">
<h3>Creación de tareas<a class="headerlink" href="#creacion-de-tareas" title="Permalink to this headline">¶</a></h3>
<p>Una de las primeras tareas que ingresa al sistema es la tarea &#8220;idle&#8221;.
Esta tarea se ejecuta en el anillo de kernel y su sola función es
quedarse a la espera de una interrupción sin consumir recursos del
procesador. El código de esta tarea se encuentre en el archivo
<tt class="docutils literal"><span class="pre">kernel/loader_helpers.asm</span></tt>, bajo la etiqueta <tt class="docutils literal"><span class="pre">idle_main</span></tt>.</p>
<p>El <tt class="docutils literal"><span class="pre">loader</span></tt> (cuyo código se encuentra en <tt class="docutils literal"><span class="pre">kernel/loader.c</span></tt>) se
ocupa de iniciar la creación de las tareas. Para que el kernel comience
la carga de una tarea, se utiliza la función <tt class="docutils literal"><span class="pre">loader_load()</span></tt>. Esta
función se encarga de inicializar un <tt class="docutils literal"><span class="pre">pcb</span></tt> para la tarea, creándole
su directorio de páginas inicial y reservando memoria para su stack de
modo kernel. Además, prepara en dicho stack un estado inicial para la
tarea y escribe en él la dirección de la función <tt class="docutils literal"><span class="pre">initialize_task</span></tt>
que será el primer código que ejecutará la tarea. Como paso final, se
realiza la llamada a <tt class="docutils literal"><span class="pre">sched_load()</span></tt> para avisar al scheduler de la
llegada de la tarea.</p>
<p>Hasta este punto, se reserva espacio para el descriptor del proceso en
los módulos <tt class="docutils literal"><span class="pre">sched</span></tt> y <tt class="docutils literal"><span class="pre">loader</span></tt>, para el stack de kernel de la
tarea, para su directorio de páginas, pero la reserva y mapeo del stack
de usuario y del código y los datos de la tarea en su espacio de
direcciones virtual, utilizando la información en el ejecutable
correspondiente, se realiza recién cuando a esta le toca ejecutarse por
primera vez. La función <tt class="docutils literal"><span class="pre">initialize_task</span></tt> es justamente la encargada
de realizar esto. El código de dicha función se encuentra en
<tt class="docutils literal"><span class="pre">kernel/loader_helpers.asm</span></tt>.</p>
</div>
<div class="section" id="cambios-de-contexto">
<h3>Cambios de contexto<a class="headerlink" href="#cambios-de-contexto" title="Permalink to this headline">¶</a></h3>
<p>El kernel realiza los cambios de contexto de las tareas por <em>software</em>.
Como consecuencia, hay una única TSS que se utiliza al mínimo: Sólo
se utilizan el campo correspondiente al selector de segmento del
stack en modo kernel (<tt class="docutils literal"><span class="pre">SS0</span></tt>) y el correspondiente al <em>stack pointer</em>
en modo kernel (<tt class="docutils literal"><span class="pre">ESP0</span></tt>). Estos campos de la TSS son utilizados por el
<em>hardware</em> para cargar los registros <tt class="docutils literal"><span class="pre">SS</span></tt> y <tt class="docutils literal"><span class="pre">ESP0</span></tt> respectivamente
al ocurrir un cambio de nivel al nivel 0.</p>
<p>Los contextos de las tareas son resguardados en sus correspondientes
stacks de kernel. Al ocurrir una interrupción mientras se está
ejecutando una tarea, el <em>handler</em> de la interrupción toma el control.
Si se precisa un cambio de contexto o si el kernel precisará el estado
actual de la tarea para algo <a class="footnote-reference" href="#id6" id="id5">[2]</a>, el handler almacena el contexto de
la tarea en el stack de modo kernel y luego llama a la rutina de
atención correspondiente (ver la sección <a class="reference external" href="#manejo-de-interrupciones">Manejo de interrupciones</a>).</p>
<p>Si la interrupción no deriva en un cambio de contexto, al terminar de
manejarla, simplemente se procede de manera inversa, cargando el estado
de la tarea desde el stack de kernel y volviendo a ejecutar en modo
usuario. Sin embargo, si la interrupción sí derivará en un cambio de
contexto, se realiza la llamada a <tt class="docutils literal"><span class="pre">loader_switchto</span></tt> que procede del
siguiente modo:</p>
<ul class="simple">
<li>guarda el registro <tt class="docutils literal"><span class="pre">EFLAGS</span></tt> (<em>flags</em> del procesador)</li>
<li>se carga el espacio de direcciones de la nueva tarea,</li>
<li>se actualizan los valores de <tt class="docutils literal"><span class="pre">SS0</span></tt> y <tt class="docutils literal"><span class="pre">ESP0</span></tt> en la TSS del sistema</li>
<li>se almacena el <em>stack pointer</em> de modo kernel actual en el <tt class="docutils literal"><span class="pre">pcb</span></tt>
de la tarea que estaba ejecutando y se carga el correspondiente a la
nueva tarea desde su <tt class="docutils literal"><span class="pre">pcb</span></tt></li>
</ul>
<p>La función <tt class="docutils literal"><span class="pre">loader_switchto()</span></tt> (<tt class="docutils literal"><span class="pre">kernel/loader.c</span></tt>) se ocupa de lo
anterior, y para el último punto utiliza la función
<tt class="docutils literal"><span class="pre">loader_switch_stack_pointers()</span></tt> definida en <tt class="docutils literal"><span class="pre">kernel/loader_helpers.asm</span></tt>.
Al retornar de dicha función, se buscará la dirección de retorno en este
&#8220;nuevo&#8221; stack. Si la tarea ya había estado en ejecución, simplemente irá
retornando hasta llegar a la parte en la que se carga el contexto desde el
stack y se vuelve a ejecutar en modo usuario. No obstante, si la tarea es una
tarea nueva, su stack fue armado cuidadosamente de manera que al retornar de
la función se ejecute el código del label <tt class="docutils literal"><span class="pre">initialize_task</span></tt>. Esta porción de
código es la encargada de reservar memoria y realizar los mapeos que ya se
nombraron antes en <a class="reference external" href="#creacion-de-tareas">Creación de tareas</a>.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>En el estado actual del código, <em>siempre</em> se resguarda el estado de la
tarea independientemente de si el kernel lo precisará o no.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="manejo-de-interrupciones">
<h2>Manejo de interrupciones<a class="headerlink" href="#manejo-de-interrupciones" title="Permalink to this headline">¶</a></h2>
<p>La función <tt class="docutils literal"><span class="pre">idt_init()</span></tt> en <tt class="docutils literal"><span class="pre">kernel/idt.c</span></tt> se ocupa de
inicializar el módulo de manejo de interrupciones. Para esto, escribe
los descriptores en la IDT para las interrupciones que serán manejadas.</p>
<p>Puede designarse el handler que se desee para cualquier índice en la IDT. Sin
embargo, existe un arreglo de handlers llamado <tt class="docutils literal"><span class="pre">idt_stateful_handlers</span></tt> que
puede ser aprovechado. Los handlers en este arreglo son generados en
<tt class="docutils literal"><span class="pre">kernel/isr.asm</span></tt>. La razón por la que hay un <em>handler</em> diferente por cada
interrupción es porque es la única forma de poder establecer qué interrupción
se está atendiendo, ya que, cuando ocurre una interrupción, se ejecuta el
código cuya dirección fue registrada en la IDT, pero el hardware no almacena
información que permita identificar de qué interrupción se trata.</p>
<p>Estas rutinas se encargan de guardar el contexto de la tarea en
ejecución en el stack de modo kernel y luego llaman a una función
común, llamada <tt class="docutils literal"><span class="pre">idt_handle()</span></tt>, pasándole a esta el índice en la IDT
de la interrupción ocurrida, un código de error si existiera y el
contexto guardado. De allí en más, <tt class="docutils literal"><span class="pre">idt_handle()</span></tt> puede ocuparse de delegar
el manejo de la interrupción en rutinas de servicio, escritas en C.</p>
<p>Una vez que <tt class="docutils literal"><span class="pre">idt_init()</span></tt> escribió la IDT, da aviso al procesador de que
tiene la IDT lista. Por último, configura los PIC y desenmascara sólo las
interrupciones de <em>hardware</em> que le interesarán al kernel.</p>
</div>
<div class="section" id="atencion-de-llamadas-al-sistema">
<h2>Atención de llamadas al sistema<a class="headerlink" href="#atencion-de-llamadas-al-sistema" title="Permalink to this headline">¶</a></h2>
<p>Las llamadas al sistema se realizan a través de la interrupción
<tt class="docutils literal"><span class="pre">0x30</span></tt>. Antes de generar la interrupción por software, el proceso
debe escribir el número correspondiente a la llamada al sistema que
desea ejecutar en el registro <tt class="docutils literal"><span class="pre">EAX</span></tt>. Los parámetros de la llamada al
sistema deben pasarse usando los registros <tt class="docutils literal"><span class="pre">EBX</span></tt>, <tt class="docutils literal"><span class="pre">ECX</span></tt> y <tt class="docutils literal"><span class="pre">EDX</span></tt>.
Al ocurrir la interrupción, la rutina de servicio de la interrupción
<tt class="docutils literal"><span class="pre">0x30</span></tt> llama a la función correspondiente a la llamada al sistema
invocada con los parámetros pasados.</p>
<p>Las llamadas al sistema implementadas hasta ahora son:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="22%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Número</th>
<th class="head">Nombre</th>
<th class="head">Función</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal"><span class="pre">exit()</span></tt></td>
<td>finaliza el proceso en ejecución y libera todos
los recursos utilizados por este</td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal"><span class="pre">getpid()</span></tt></td>
<td>devuelve el identificador de proceso de la
tarea</td>
</tr>
<tr><td>3</td>
<td><tt class="docutils literal"><span class="pre">palloc()</span></tt></td>
<td>reserva una página de memoria para la tarea</td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal"><span class="pre">read()</span></tt></td>
<td>lee de un archivo abierto</td>
</tr>
<tr><td>5</td>
<td><tt class="docutils literal"><span class="pre">write()</span></tt></td>
<td>escribe en un archivo abierto</td>
</tr>
<tr><td>6</td>
<td><tt class="docutils literal"><span class="pre">seek()</span></tt></td>
<td>traslada el puntero del archivo a una posición
dada</td>
</tr>
<tr><td>7</td>
<td><tt class="docutils literal"><span class="pre">close()</span></tt></td>
<td>cierra el archivo y libera los recursos
que ya no se precisen</td>
</tr>
<tr><td>8</td>
<td><tt class="docutils literal"><span class="pre">open()</span></tt></td>
<td>abre un archivo para lectura y/o escritura</td>
</tr>
<tr><td>9</td>
<td><tt class="docutils literal"><span class="pre">con_ctl()</span></tt></td>
<td>envía comandos de control a una consola</td>
</tr>
<tr><td>10</td>
<td><tt class="docutils literal"><span class="pre">run()</span></tt></td>
<td>pone un programa en ejecución</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="la-memoria">
<h2>La memoria<a class="headerlink" href="#la-memoria" title="Permalink to this headline">¶</a></h2>
<div class="section" id="gestion-de-la-memoria">
<h3>Gestión de la memoria<a class="headerlink" href="#gestion-de-la-memoria" title="Permalink to this headline">¶</a></h3>
<p>El módulo encargado de la gestión de la memoria es el módulo <tt class="docutils literal"><span class="pre">mm</span></tt>
(<tt class="docutils literal"><span class="pre">kernel/mm.c</span></tt>). Su función de inicialización, <tt class="docutils literal"><span class="pre">mm_init()</span></tt>, se encarga de</p>
<ol class="arabic simple">
<li>armar la lista de páginas libres para el kernel y para usuario,</li>
<li>inicializar un directorio de páginas para el kernel y</li>
<li>activar la paginación de memoria.</li>
</ol>
<p>Para el paso 1, recorre la memoria verificando qué páginas de memoria son
válidas y arma dos listas de páginas libres: las del kernel, que están por
debajo de los 4MB de memoria física, y las de usuario.</p>
<p>Cada página de memoria física disponible está representada por una estructura
<tt class="docutils literal"><span class="pre">page_t</span></tt>.  Dicha estructura se encuentra declarada en <tt class="docutils literal"><span class="pre">kernel/mm.c</span></tt> del
siguiente modo:</p>
<div class="highlight-python"><pre>struct page_t {
    int count;

    page_t *next;
    page_t *prev;
};</pre>
</div>
<p>Los punteros <tt class="docutils literal"><span class="pre">next</span></tt> y <tt class="docutils literal"><span class="pre">prev</span></tt> son utilizados para administrar las
listas de páginas físicas libres y``count`` indica el número de
referencias de la página.</p>
<p>En el módulo <tt class="docutils literal"><span class="pre">mm</span></tt> se encuentran todas las funciones que se ocupan
de gestionar las páginas físicas libres y de mapearlas a los espacios
de direcciones virtuales.</p>
</div>
<div class="section" id="direccionamiento">
<h3>Direccionamiento<a class="headerlink" href="#direccionamiento" title="Permalink to this headline">¶</a></h3>
<p>Una de las primeras cosas que se realizan en <tt class="docutils literal"><span class="pre">kernel/kinit.asm</span></tt>
(el código al que salta el bootloader) es configurar una GDT definitiva
para el sistema. La misma está compuesta por descriptores para:</p>
<ol class="arabic simple">
<li>Código de nivel 0</li>
<li>Datos de nivel 0</li>
<li>Código de nivel 3</li>
<li>Datos de nivel 3</li>
<li>TSS del sistema</li>
</ol>
<p>Tanto los segmentos de código como de datos ocupan todo el espacio
direccionable. El principal mecanismo de protección de memoria
utilizado en el kernel es la paginación.</p>
<p>Cada tarea cuenta con un espacio de direcciones virtual propio, pero todas
ellas tienen al código y los datos del kernel mapeados en las direcciones
bajas (<em>lower half</em>) mientras que el código y los datos de usuario se
encuentran en direcciones más altas.</p>
</div>
</div>
<div class="section" id="devices">
<h2><em>Devices</em><a class="headerlink" href="#devices" title="Permalink to this headline">¶</a></h2>
<p>El <em>device</em> es una abstracción que permite manipular dispositivos de
<em>hardware</em> y estructuras lógicas con facilidad y mediante una interfaz
común.</p>
<p>Cada tipo de device está representado por una estructura específica.
Sin embargo, todas estas estructuras &#8220;derivan de&#8221; una estructura en
particular. En este contexto, una estructura deriva de otra si todos
los campos de esta última están incluidos al principio (y en el mismo
orden) en la primera. La estructura más general de device, definida en
<tt class="docutils literal"><span class="pre">include/device.h</span></tt>, es:</p>
<div class="highlight-python"><pre>struct device {
    uint32_t clase;
    uint32_t refcount;
    dev_flush_t *flush;
};</pre>
</div>
<p>La <tt class="docutils literal"><span class="pre">clase</span></tt> define de qué tipo de device se trata y, consecuentemente,
cuál es la estructura asociada. <tt class="docutils literal"><span class="pre">refcount</span></tt> indica el número de
referencias, es decir, la cantidad de usuarios del device. Por último,
<tt class="docutils literal"><span class="pre">flush</span></tt> es una función que se llama cuando el device dejará de ser
utilizado y se encarga de liberar los recursos utilizados por el mismo.</p>
<p>Las principales estructuras que derivan de <tt class="docutils literal"><span class="pre">device</span></tt> son <tt class="docutils literal"><span class="pre">chardev</span></tt> y
<tt class="docutils literal"><span class="pre">blockdev</span></tt>. La primera estructura representa un device que puede
accederse comúnmente como una tira de bytes. La segunda representa uno
que puede acceders2e de a porciones definidas (bloques):</p>
<div class="highlight-python"><pre>struct chardev {
    uint32_t clase;
    uint32_t refcount;
    chardev_flush_t *flush;
    chardev_read_t *read;
    chardev_write_t *write;
    chardev_seek_t *seek;
};

struct blockdev {
    uint32_t clase;
    uint32_t refcount;
    blockdev_flush_t *flush;
    blockdev_read_t *read;
    blockdev_write_t *write;
    uint32_t size;
};</pre>
</div>
<p>Ambas respetan los campos de la estructura <tt class="docutils literal"><span class="pre">device</span></tt> por &#8220;derivar&#8221; de
ella. La diferencia entre las funciones de lectura y escritura de los
<tt class="docutils literal"><span class="pre">chardev</span></tt> y los <tt class="docutils literal"><span class="pre">blockdev</span></tt> es, básicamente, que para los primeros
se asume que existe una posición actual, fijada con <tt class="docutils literal"><span class="pre">seek</span></tt>, (o que no
es relevante especificar una posición) a partir de la cual leer,
mientras que para los segundos la posición debe especificarse y
normalmente indica un número de bloque.</p>
<div class="section" id="las-consolas">
<h3>Las consolas<a class="headerlink" href="#las-consolas" title="Permalink to this headline">¶</a></h3>
<p>El módulo <tt class="docutils literal"><span class="pre">con</span></tt> implementa el anillo de consolas. Las consolas son
esencialmente <em>buffers</em> de memoria destinados a ser representados en
la pantalla como texto. En todo momento hay una consola que se
encuentra &#8220;en foco&#8221;, es decir, visible en la pantalla.</p>
<p>Cada consola está representada por una estructura <tt class="docutils literal"><span class="pre">con_chardev</span></tt>,
definida en <tt class="docutils literal"><span class="pre">include/con.h</span></tt>:</p>
<div class="highlight-python"><pre>struct con_chardev {
    uint32_t clase;
    uint32_t refcount;
    chardev_flush_t* flush;
    chardev_read_t* read;
    chardev_write_t* write;
    chardev_seek_t* seek;

    void *screen_buf;
    uint32_t screen_buf_offset;

    circular_buf_t kb_buf;
    int waiting_process;

    uint8_t current_attr;

    con_chardev *next;
    con_chardev *prev;
}</pre>
</div>
<p>Esta estructura alberga la dirección virtual del buffer de la consola y
la posición actual en este buffer en <tt class="docutils literal"><span class="pre">screen_buf</span></tt> y
<tt class="docutils literal"><span class="pre">screen_buf_offset</span></tt> respectivamente. Al realizarse una escritura
sobre el device, llamando a su funcion <tt class="docutils literal"><span class="pre">write</span></tt>, se almacenan los
datos en el buffer y se avanza el puntero en <tt class="docutils literal"><span class="pre">screen_buf_offset</span></tt> de
manera acorde. Cuando se llega al final del buffer, se produce un
desplazamiento de los datos que consiste en mover todo el contenido del
buffer 80 caracteres (una línea) hacia atrás y limpiar los últimos 80
caracteres del buffer.</p>
<p>Si se llama a la función <tt class="docutils literal"><span class="pre">read</span></tt> de la consola, la tarea en ejecución
queda a la espera de que se oprima una tecla en el teclado. Cuando esto
ocurre, la rutina de atención de la interrupción del teclado avisa al
módulo <tt class="docutils literal"><span class="pre">kb</span></tt> del evento, el cual se encarga de enviarle al módulo
<tt class="docutils literal"><span class="pre">con</span></tt> el caracter recibido. La función <tt class="docutils literal"><span class="pre">con_put_to_kb_buf</span></tt>
finalmente se encarga de almacenar el caracter en el buffer <tt class="docutils literal"><span class="pre">kb_buf</span></tt>
de la consola en foco y de despertar a la tarea en espera. Al
despertarse la tarea, la función <tt class="docutils literal"><span class="pre">read</span></tt> ya puede leer del buffer de
teclado los caracteres recibidos y guardarlos donde se le indicó (por
ejemplo, un buffer de usuario).</p>
</div>
<div class="section" id="el-puerto-serie">
<h3>El puerto serie<a class="headerlink" href="#el-puerto-serie" title="Permalink to this headline">¶</a></h3>
<p>El kernel incluye un controlador para UART (<em>Universal Asynchronous
Receiver/Transmitter</em>), que permite leer de y escribir al conocido
&#8220;puerto serie&#8221;. Para representar al dispositivo se utiliza la estructura
<tt class="docutils literal"><span class="pre">serial_chardev</span></tt>, definida en <tt class="docutils literal"><span class="pre">include/serial.h</span></tt>.</p>
<p>El funcionamiento para el caso de la lectura es similar al caso de la
consola. La tarea queda bloqueada a la espera de la llegada de un byte.
Cuando este llega, se almacena en el buffer del dispositivo y se
despierta a la tarea para que esta pueda tomar el dato. Para el caso de
la escritura, simplemente se envían al dispositivo uno a uno los bytes
a transmitir, esperando entre cada envío que el dispositivo se
encuentre listo.</p>
</div>
<div class="section" id="disco-rigido-ata-ide">
<h3>Disco rígido ATA IDE<a class="headerlink" href="#disco-rigido-ata-ide" title="Permalink to this headline">¶</a></h3>
<p>El módulo <tt class="docutils literal"><span class="pre">hdd</span></tt> se encarga del manejo de los discos ATA IDE. El modo
de acceso a los discos es el de entrada/salida programada. De momento
sólo se ha implementado la funcionalidad de lectura de disco, sin tener
en cuenta los permisos de usuario.</p>
<p>La estructura <tt class="docutils literal"><span class="pre">hdd_blockdev</span></tt> representa al disco rígido. Respetando
los prototipos de las funciones de los <tt class="docutils literal"><span class="pre">blockdev</span></tt>, la función de
lectura recibe, además de un buffer con su respectivo tamaño, la
posición del bloque a leer, expresada como una dirección LBA (Logical
Block Addressing) de 28 bits. La operatoria es similar a los demás
dispositivos: Se envía el pedido de sectores al disco y se bloquea la
tarea a la espera de recibir los datos en un buffer. El buffer es
llenado (y la tarea desbloqueada) cuando la rutina de atención de la
interrupción del disco se encarga de obtener los datos.</p>
</div>
</div>
<div class="section" id="el-sistema-de-archivos-virtual">
<h2>El sistema de archivos virtual<a class="headerlink" href="#el-sistema-de-archivos-virtual" title="Permalink to this headline">¶</a></h2>
<p>El nombre &#8220;sistema de archivos virtual&#8221; quizás le queda algo grande a
la rústica implementación que llevamos a cabo, en el módulo <tt class="docutils literal"><span class="pre">fs</span></tt> para
tener un manejo mínimo de los archivos en el <em>filesystem</em> físico y de
los dispositivos de hardware.</p>
<p>La llamada al sistema <tt class="docutils literal"><span class="pre">open()</span></tt> permite la apertura de un archivo para
su posterior lectura o escritura. La implementación de esta llamada es
la siguiente:</p>
<div class="highlight-python"><pre>int sys_open(char *path, uint32_t mode) {
    chardev *cdev;
    if (!(cdev = fs_open(path, mode)))
        return -ENOFILE;
    else {
        cdev-&gt;refcount++;
        return loader_add_file(cdev);
    }
}</pre>
</div>
<p>Simplemente, la llamada recibe una ruta y un modo de apertura. Ambos
datos se pasan a la función <tt class="docutils literal"><span class="pre">fs_open()</span></tt>, que se encarga de encontrar
un <tt class="docutils literal"><span class="pre">chardev</span></tt> correspondiente a esa ruta, si lo hay, o devolver
<tt class="docutils literal"><span class="pre">NULL</span></tt>. Una vez que se obtuvo el <tt class="docutils literal"><span class="pre">chardev</span></tt> correspondiente a la
ruta, la función <tt class="docutils literal"><span class="pre">loader_add_file()</span></tt> agrega el <tt class="docutils literal"><span class="pre">chardev</span></tt> a la lista
de dispositivos abiertos por la tarea y devuelve un nuevo <em>file
descriptor</em>.</p>
<p>Para encontrar el <tt class="docutils literal"><span class="pre">chardev</span></tt>, <tt class="docutils literal"><span class="pre">fs_open()</span></tt> simplemente respeta
algunas reglas:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">/serial0</span></tt> y <tt class="docutils literal"><span class="pre">/serial1</span></tt> representan los <tt class="docutils literal"><span class="pre">chardev</span></tt>
correspondientes a los &#8220;puertos serie&#8221;;</li>
<li><tt class="docutils literal"><span class="pre">/console</span></tt> representa una nueva consola, y <tt class="docutils literal"><span class="pre">/console&lt;i&gt;</span></tt> siendo
<tt class="docutils literal"><span class="pre">&lt;i&gt;</span></tt> un entero no negativo representa la consola número <tt class="docutils literal"><span class="pre">&lt;i&gt;</span></tt>;</li>
<li>por último, <tt class="docutils literal"><span class="pre">/disk/&lt;ruta&gt;</span></tt> representa el archivo en la ruta
<tt class="docutils literal"><span class="pre">&lt;ruta&gt;</span></tt> en el filesystem existente en el disco rígido.</li>
</ul>
<div class="section" id="sistema-de-archivos-ext2">
<h3>Sistema de archivos ext2<a class="headerlink" href="#sistema-de-archivos-ext2" title="Permalink to this headline">¶</a></h3>
<p>El único sistema de archivos implementado para el disco rígido es ext2,
en su primera versión. Se lo implementó de manera rudimentaria, con
soporte para lectura y sin tener en cuenta permisos.</p>
<p>La primera implementación leía el archivo entero y lo almacenaba en un
buffer al momento de la apertura. La versión actual permite la lectura
y almacenamiento de los datos del archivo de a secciones y bajo
demanda.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">El sistema por dentro</a><ul>
<li><a class="reference internal" href="#la-estructura-de-directorios">La estructura de directorios</a></li>
<li><a class="reference internal" href="#manejo-de-procesos">Manejo de procesos</a><ul>
<li><a class="reference internal" href="#el-descriptor-de-proceso">El descriptor de proceso</a></li>
<li><a class="reference internal" href="#el-scheduler">El <em>scheduler</em></a></li>
<li><a class="reference internal" href="#creacion-de-tareas">Creación de tareas</a></li>
<li><a class="reference internal" href="#cambios-de-contexto">Cambios de contexto</a></li>
</ul>
</li>
<li><a class="reference internal" href="#manejo-de-interrupciones">Manejo de interrupciones</a></li>
<li><a class="reference internal" href="#atencion-de-llamadas-al-sistema">Atención de llamadas al sistema</a></li>
<li><a class="reference internal" href="#la-memoria">La memoria</a><ul>
<li><a class="reference internal" href="#gestion-de-la-memoria">Gestión de la memoria</a></li>
<li><a class="reference internal" href="#direccionamiento">Direccionamiento</a></li>
</ul>
</li>
<li><a class="reference internal" href="#devices"><em>Devices</em></a><ul>
<li><a class="reference internal" href="#las-consolas">Las consolas</a></li>
<li><a class="reference internal" href="#el-puerto-serie">El puerto serie</a></li>
<li><a class="reference internal" href="#disco-rigido-ata-ide">Disco rígido ATA IDE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#el-sistema-de-archivos-virtual">El sistema de archivos virtual</a><ul>
<li><a class="reference internal" href="#sistema-de-archivos-ext2">Sistema de archivos ext2</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Trabajo Práctico de Programación de Sistemas Operativos</a></li>
      <li>Next: <a href="conventions.html" title="next chapter">Convenciones para el código de este trabajo</a></li>
  </ul></li>
</ul>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="sources/inside.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2011, Pablo Antonio, Pablo Herrero.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>